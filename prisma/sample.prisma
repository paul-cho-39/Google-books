// should generate RPG-esque so that user levels up 
// for every book read?

// get rid of library or NOT? draw a map
// might not even require "Log relation with bookId?"
model Log {
    id           Int        @id @default(autoincrement())
    start        DateTime[]
    end          DateTime[]
    dayOfTheWeek String[]
    bookId       String
    libraryId    String
    book         Book       @relation(fields: [bookId], references: [libraryId], onDelete: Cascade)
    library      Library    @relation(fields: [libraryId], references: [id])

    @@map("reading_logs")
}

// change dateAdded?
model Book {
    id                  String
    title               String
    subtitle            String?
    publishedDate       DateTime @map("pub_date")
    libraryId           String   @unique
    categories          String[]
    language            String?  @default("en")
    pageCount           Int?
    industryIdentifiers Json?
    imageLinks          Json?
    authors             String[]
    readMultiples       Int?     @map("reread_multiples")
    userId              String
    user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    library             Library  @relation(fields: [libraryId], references: [id], onDelete: Cascade)
    readingLog          Log[]

    // if re-reading then it is better to introduce another variable no?
    // if allowed to readMultiples then how would this go about?
    @@unique([id, userId])
    @@index([id])
    @@map("book")
}

model Library {
    id                   String    @id @default(cuid())
    userId               String
    primary              Boolean   @default(false)
    primaryAdded         DateTime  @default(now()) @map("primary_added")
    currentlyReading     Boolean?  @default(false)
    readingAdded         DateTime?
    wantToRead           Boolean?
    wantToReadLastUpdate DateTime? @map("last_update")
    finishedReading      Boolean   @default(false)
    // remove finishedDate?
    finishedDate         DateTime?
    finishedYear         Int?      @map("finished_year")
    finishedMonth        Int?      @map("finished_month")
    finishedDay          Int?      @map("finished_day")
    user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    books                Book[]
    reading_log          Log[]

    @@index([userId])
    @@map("library")
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    emailVerified DateTime?
    birthOfDate   DateTime? @map("bod")
    image         String?
    password      String?
    username      String?   @unique
    account       Account[]
    sessions      Session[]
    library       Library[]
    book          Book[]
    // location      Location?

    @@index([id])
    @@map("users")
}

// have to test how to add the location here
// model Location {
//   id       String @id @default(cuid()) @ignore
//   userId   String @unique
//   timeZone String
//   user     User   @relation(fields: [id], references: [id], onDelete: Cascade)
// }

model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String?
    access_token      String?
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String?
    session_state     String?
    user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}
